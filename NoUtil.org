#+BEGIN_SRC java
import java.lang.management.ManagementFactory;
import java.net.NetworkInterface;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.security.SecureRandom;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * <p>https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/types/ObjectId.java</p>
 * <pre>由以下几个部分组成:
 * 1. 生成序列号的行为. 如 D 表示订单, X 表示提现, T 表示退款 等
 * 2. 时间规则的 hashcode 值
 * 3. 自增值. 这个值基于当前进程是同步的. 基于 concurrent 下的 atomic 类实现, 避免 synchronized 锁
 * 4. 机器码 + 进程号合并后的 hashcode 值
 *       机器码: 当前机器的 mac 地址. 在多台不同的机器时, 此规则可以区分
 *       进程号: 运行此 jvm 的进程号. 在一台机器的多个不同进程时, 此规则可以区分</pre>
 * <table border="1">
 *     <tr>
 *         <td>1</td>
 *         <td>2</td>
 *         <td>3</td>
 *         <td>4</td>
 *     </tr>
 *     <tr>
 *         <td>behavior</td>
 *         <td>time.hashCode.sub</td>
 *         <td>inc</td>
 *         <td>(machine + pid).hashCode.sub</td>
 *     </tr>
 * </table>
 * <pre>
 *
 * 如果基于 redis 的 cluster 或者 主从 来达到高可用(HA) 的话:
 *     弄一个定时任务操作 redis 中的一个 set, 当长度小于某个值时再基于 set 中的最大值生成指定数量的项(加步长)存进去.
 *     适时调整相关的数量及定时任务的周期来达到需求最优即可.
 *
 *     取的时候每次都基于 set 随机取即可.
 *
 * 长度问题: 就算 1 天 10 亿单, 双十一那天 1000 亿单
 * (1,000,000,000 * 365(天) + 100,000,000,000) * 100(年) * 13(步长) => 604,500,000,000,000
 * 15 位还没用有用完. 其实对于真实世界来说, 10 多位是完全够用的.
 * </pre>
 */
public final class NoUtil {

    private static final Logger LOGGER = Logger.getLogger(NoUtil.class.getName());

    /** 机器码 加 进程号 会导致生成的序列号很长, 基于这两个值做一些截取 */
    private static final String MP;
    /** 截取长度 */
    private static final int HORIZONTAL_LEN = 4;
    static {
        // 机器码 --> 本机 mac 地址的 hashcode 值
        int machineIdentifier = createMachineIdentifier();
        // 进程号 --> 当前运行的 jvm 进程号的 hashcode 值
        int processIdentifier = createProcessIdentifier();

        String mp = Integer.toString(Math.abs((machineIdentifier + "" + processIdentifier).hashCode()));
        MP = (mp.length() > HORIZONTAL_LEN) ? mp.substring(mp.length() - HORIZONTAL_LEN, mp.length()) : mp;
    }

    private static int createMachineIdentifier() {
        // build a 2-byte machine piece based on NICs info
        int machinePiece;
        try {
            StringBuilder sb = new StringBuilder();
            Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces();
            while (e.hasMoreElements()) {
                NetworkInterface ni = e.nextElement();
                sb.append(ni.toString());
                byte[] mac = ni.getHardwareAddress();
                if (mac != null) {
                    ByteBuffer bb = ByteBuffer.wrap(mac);
                    try {
                        sb.append(bb.getChar());
                        sb.append(bb.getChar());
                        sb.append(bb.getChar());
                    } catch (BufferUnderflowException shortHardwareAddressException) { //NOPMD
                        // mac with less than 6 bytes. continue
                    }
                }
            }
            machinePiece = sb.toString().hashCode();
        } catch (Throwable t) {
            // exception sometimes happens with IBM JVM, use random
            machinePiece = new SecureRandom().nextInt();
            LOGGER.log(Level.WARNING, "Failed to get machine identifier from network interface, using random number instead", t);
        }
        return machinePiece;
    }

    // Creates the process identifier. This does not have to be unique per class loader because
    // NEXT_COUNTER will provide the uniqueness.
    private static int createProcessIdentifier() {
        int processId;
        try {
            String processName = ManagementFactory.getRuntimeMXBean().getName();
            if (processName.contains("@")) {
                processId = Integer.parseInt(processName.substring(0, processName.indexOf('@')));
            } else {
                processId = processName.hashCode();
            }
        } catch (Throwable t) {
            processId = new SecureRandom().nextInt();
            LOGGER.log(Level.WARNING, "Failed to get process identifier from JMX, using random number instead", t);
        }
        return processId;
    }

    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("HHyyssMMmmdd");
    private static String unitCode() {
        String unit = Integer.toString(Math.abs(DATE_FORMAT.format(new Date()).hashCode()));
        return unit.substring(unit.length() - HORIZONTAL_LEN, unit.length());
    }

    /** 生成序列号的类型 */
    private enum Category {
        /** 订单: 标识, 初始值, 步长, 最大值(只要保证之内, 从初始化值加步长不会超时最大值就不会有重复) */
        Order("D", 16, 3, 10000000);

        String behavior;
        int init, step, max;
        AtomicLong counter;
        Lock lock;
        Category(String behavior, int init, int step, int max) {
            this.behavior = behavior;
            this.init = init;
            this.step = step;
            this.max = max - step;

            counter = new AtomicLong(init);
            lock = new ReentrantLock();
        }
        public String no() {
            long increment = counter.addAndGet(step);
            if (increment >= max) {
                lock.lock();
                try {
                    if (increment >= max) {
                        increment = counter.getAndSet(init);
                    }
                } finally {
                    lock.unlock();
                }
            }
            return behavior + unitCode() + increment + MP;
        }
    }

    /** 生成订单号: (到秒的 12 位 + 1 个占位 + 4 位网卡及进程 + 2 位进程自增值) */
    public static String getOrderNo() {
        return Category.Order.no();
    }
}
#+END_SRC


Test

#+BEGIN_SRC java
import org.junit.Test;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.*;

public class NoTest {

    private static final int count = 1000000;

    private static final ExecutorService EXEC = Executors.newCachedThreadPool();

    @Test
    public void generateOrderNo() throws Exception {
        long start = System.currentTimeMillis();
        System.out.println("start order:" + time(new Date(start)));

        List<Callable<String>> callList = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            callList.add(NoUtil::getOrderNo);
        }
        List<Future<String>> futures = EXEC.invokeAll(callList, 1, TimeUnit.MINUTES);
        Set<String> set = new HashSet<>();
        for (Future<String> future : futures) {
            set.add(future.get());
        }
        EXEC.shutdownNow();
        System.out.println(String.format("all : %s\nreal: %s", count, set.size()));

        long end = System.currentTimeMillis();
        System.out.println("end order : " + time(new Date(end)));
        System.out.println("耗时: " + ((end - start) / 1000.0));
    }
    
    private static String time(Date date) {
        return new SimpleDateFormat("yy-MM-dd HH:mm:ss SSS").format(date);
    }
}
#+END_SRC
