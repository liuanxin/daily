
*** Queue

Queue 是 Java Collection Framework 中队列分支的超级接口, 在它下面有这些子接口:
+ BlockingQueue 阻塞队列(出入队列时如果不满足条件将挂起线程并直到成功)
+ Deque 双端队列. 允许在两端添加或删除元素
+ BlockingDeque 类似于 BlockingQueue 的双端队列, 它是 BlockingQueue 的子接口
从 java 7 开始, BlockingQueue 有一个 TransferQueue 的新子接口, 它等待另一个线程检索队列中的元素

队列实现主要分为两组: 通用(general-purpose) 和 并发实现(concurrent implementations)

通用队列实现有:
+ ArrayDeque 基于 Deque 的简单实现, 当想利用双端队列的特性而不使用链表时, 可以考虑使用(比 LinkedList 简单)
+ LinkedList 实现了 List 和 Deque 接口, 具有链表和队列的混合特性行为, 当想快速添加和移除两端的元素时可以考虑使用
+ PriorityQueue 根据元素的自然顺序或构造时提供的比较器来排列元素

并发队列实现有:
+ ConcurrentLinkedQueue 基于链表结构实现的线程安全却非阻塞的单向 fifo 队列
+ ArrayBlockingQueue 基于数组结构实现的阻塞队列, impl BlockingQueue
+ LinkedBlockingQueue 基于链表结构实现的阻塞队列, impl BlockingQueue
+ PriorityBlockingQueue 想利用 PriorityQueue 和 BlockingQueue 时使用此类
+ DelayQueue 基于时间的调度阻塞队列, 添加到此队列的元素必须实现 Delayed 接口. 元素只能在延迟到期时才能取出, impl BlockingQueue
+ SynchronousQueue 双向等待的队列模型, 出等待入, 入等待出, impl BlockingQueue

#+BEGIN_EXAMPLE
BlockingQueue 使用 Lock 及 Condition 实现阻塞(lock 本质上也是基于 cas, 但毕竟是间接操作且会导致线程挂起)
ConcurrentLinkedQueue 使用 cas + 循环尝试(自旋)操作来实现非阻塞算法来取得最大的吞吐量

PriorityBlockingQueue 是一个支持排序的队列, 基于数组而且是无界的, 只有 take 才会阻塞, put 不会(除非达到 Integer.MAX).
总的来说它并不是一个 fifo 队列, 而是一个有序的队列, 入队列不阻塞出队列阻塞, 所有操作都是线程安全的.

同步队列 SynchronousQueue 没有 peek 操作(也就没有 element), 因为没有内部容量, 只有在移除时该元素才存在.
这种设计中, 一个在线程中运行的对象要将某些信息、事件或任务传递给另一个线程中的对象时, 必须与该对象同步. 
这是一种快速传递元素的方式, 在这种情况下元素总是以最快的方式从生产者传递给消费者. 多任务队列中这是最快处理任务的方式

延时队列 DelayQueue 每次获取最先到达延时的元素, 使用场景像计划任务.
#+END_EXAMPLE


由于 Queue 扩展了 Collection 接口, 所以 Queue 实现都有集合的基本操作
+ 单操作: bool add(E), bool contains(Obj), iter, void clear(), bool isEmpty(), int size(), [] toArray()
+ 批量操作: bool addAll(Coll), bool containsAll(Coll), bool removeAll(Coll), bool retainAll(Coll)

Queue 接口的 api 总结如下
| 操作          | 抛出异常                 | 返回值                       | 描述               |
|---------------+--------------------------+------------------------------+--------------------|
| 入(insert)    | bool add(E) 满时抛出异常 | bool offer(E) 满时返回 false | 将元素加到队列尾部 |
| 出(remove)    | E remove()  空时抛出异常 | E poll()      空时返回 null  | 检查并返回队列头   |
| 检查(examine) | E element() 空时抛出异常 | E peek()      空时返回 null  | 返回头元素但不移除 |

Deque 抽象出一个双端队列(first & last), 它的 api 也是围绕这个特性构建, 总结如下
| 操作          | 第一个元素                   | 最后一个元素               |
| 入(insert)    | addFirst(E)    offerFirst(E) | addLast(E)    offerLast(E) |
| 出(remove)    | removeFirst()  pollFirst()   | removeLast()  pollLast()   |
| 检查(examine) | getFirst()     peekFirst()   | getLast()     peekLast()   |

BlockingQueue 在入队列时已满则等待, 出队列时已空则等待, 另外还提供插入和删除元素时可以等待指定的持续时间, 总结如下
| 操作          | 抛出异常 | 返回值 | 阻塞                       | 超时                         |
|---------------+----------+--------+----------------------------+------------------------------|
| 入(insert)    | add      | offer  | void put(E) 队列满时将等待 | boolean offer(E, time, unit) |
| 出(remove)    | remove   | poll   | E take()    队列空时将等待 | E poll(time, unit)           |
| 检查(examine) | element  | peek   | ?                          | ?                            |

BlockingDeque 的 api 总结如下
| 第一个元素   (head) |               |               |             |                           |
| 操作                | 抛出异常      | 返回值        | 阻塞        | 超时                      |
| 入(insert)          | addFirst(E)   | offerFirst(E) | putFirst(E) | offerFirst(E, time, unit) |
| 出(remove)          | removeFirst() | pollFirst()   | takeFirst() | pollFirst(time, unit)     |
| 检查(examine)       | getFirst()    | peekFirst()   | ?           | ?                         |
|                     |               |               |             |                           |
| 最后一个元素 (tail) |               |               |             |                           |
| 操作                | 抛出异常      | 返回值        | 阻塞        | 超时                      |
| 入(insert)          | addLast(E)    | offerLast(E)  | putLast(E)  | offerLast(E, time, unit   |
| 出(remove)          | removeLast()  | pollLast()    | takeLast()  | pollLast(time, unit)      |
| 检查(examine)       | getLast()     | peekLast()    | ?           | ?                         |


常见的 BlockingQueue 对比如下, 加上了 ConcurrentLinkedQueue 这个非阻塞队列
| 队列                  | 场景                                                        | 优点                                                        | 缺点                                                                                     |
|-----------------------+-------------------------------------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------|
| ConcurrentLinkedQueue | 队列的最佳线程安全版本, 在不适用阻塞功能时是最有效的        | 使用原子操作, 效率最高, 也是一种无界队列                    | 不能阻塞线程, 因此无法获取队列大小,也无法控制队列容量                                    |
| LinkedBlockingQueue   | 基于链表实现的可阻塞线程安全队列                            | 阻塞, 出入队列锁分离, 效率高,支持容量限制, 也能作为无界队列 | 存在锁机制, 且定位元素需要遍历, 因此效率上有一定影响                                     |
| ArrayBlockingQueue    | 基于数组实现的可阻塞线程安全队列, 容量固定时不错的阻塞实现  | 阻塞, 出入队列效率更高, 同时还省内存                        | 容量固定, 不能扩容, 出入队列不能同时进行                                                 |
| PriorityBlockingQueue | 按照自然排序实现的阻塞队列,元素需要排序(优先级)时的唯一选择 | 阻塞, 元素有序, 能自动扩容                                  | 出入队列比较慢, 效率较低, 基于数组实现, 扩容需要数组复制, 容量不能减小, 入队列不能被阻塞 |
| SynchronousQueue      | 直接交换元素的实现, 快速处理任务队列时最有效的方式          | 阻塞, 快速交换队列                                          | 内部没有容量                                                                             |
| DelayQueue            | 延时处理队列, 每个元素都有一个延时时间, 时间过期才能出队列  | 阻塞, 可延时                                                | 基于 PriorityQueue 实现(排序), 效率很低, 入队列不能被阻塞                                |

#+BEGIN_EXAMPLE
如果不需要阻塞队列则选择 ConcurrentLinkedQueue.
如果需要阻塞队列
    队列大小固定选择 ArrayBlockingQueue, 不固定则选择 LinkedBlockingQueue
    需要对队列排序(优先级)选择 PriorityBlockingQueue
    需要一个快速交换的队列选择 SynchronousQueue
    需要对队列中的元素进行延时操作选择 DelayQueue
#+END_EXAMPLE


*** Deque(double ended queue 双端队列)
#+BEGIN_EXAMPLE
允许在头尾进行 入队出队 操作, 还可以实现堆栈, 功能上比 Queue 更复杂.

Linkedlist 基于链表结构实现的双向队列
ArrayDeque 基于数组结构实现的双向队列
LinkedBlockingDeque 基于链表结构实现的阻塞双端队列(线程安全), lock + condition 类似于 ArrayBlockingQueue
#+END_EXAMPLE


*** 线程池

合理使用线程池能带来 3 个很明显的好处:
1. 降低资源消耗: 通过重用已创建的线程来降低线程创建和销毁的消耗
1. 提高响应速度: 任务到达时不需要等待就可以立即执行
1. 提高线程的可管理性: 线程池可以统一管理、分配、调优和监控

任务的执行策略包括 4W3H 部分:
+ 任务在什么(What)线程中执行
+ 任务以什么(What)顺序执行(FIFO/LIFO/优先级等)
+ 同时有多少个(How Many)任务在并发执行
+ 允许有多少个(How Many)任务进入执行队列
+ 系统过载时放弃哪个(Which)任务, 怎么(How)通知应用程序这个动作
+ 任务执行的开始、结束应该什么什么(What)处理

线程池的基本原理和执行方法
1. 有运行、关闭、停止、结束四种状态, 结束后就会释放所有资源
1. 平缓关闭线程池使用 shutdown()
1. 立即关闭线程池使用 shutdownNow(), 同时得到未执行的任务列表
1. 检测线程池是否正处于关闭中使用 isShutdown()
1. 检测线程池是否已经关闭使用 isTerminated()
1. 定时或者永久等待线程池关闭结束使用 awaitTermination()

各参数说明
+ corePoolSize 核心数大小
+ maxmumPoolSize 最大容量大小
+ keepAliveTime 空闲时线程存活的时间
+ ThreadFactory 生成线程的线程工厂
+ blockingQueue 任务队列
+ rejectedExecutionHandler 拒绝策略

RejectedExecutionHandler 提供了四种方式来处理任务拒绝策略
1. 不用线程池中的线程执行: CallerRunsPolicy
1. 抛出异常: AbortPolicy
1. 丢弃要加入到队列的任务: DiscardPolicy
1. 丢弃队列中旧的任务: DiscardOldestPolicy

ScheduleExecutorService 基于 ExecutorService 的两个方式不同点(下面 cost 为执行时间)
+ scheduleAtFixedRate(R, init, per, TU) 加入后 init 开始执行, 而后每过 max(cost, per) 执行一次
+ scheduleWithFixedDelay(R, init, delay, TU) 加入后 init 开始执行, 而后每过 (delay + cost) 再执行一次


在 ~ThreadPoolExecutor~ 中有这样一段说明
#+BEGIN_QUOTE
programmers are urged to use the more convenient Executors factory methods 
Executors.newCachedThreadPool (unbounded thread pool, with automatic thread reclamation), 
Executors.newFixedThreadPool (fixed size thread pool) 
and Executors.newSingleThreadExecutor (single background thread),
that preconfigure settings for the most common usage scenarios
#+END_QUOTE

#+BEGIN_EXAMPLE
意思是说推荐使用较为方便的 Executors 工厂方法, 它们均为大多数使用场景预定义了设置.
  newCachedThreadPool() (无界线程池, 可以自动线程回收),
  newFixedThreadPool(int) (固定大小线程池),
  newSingleThreadExecutor() (单个后台线程)
#+END_EXAMPLE


Executors 中的静态方法主要有
1. newSingleThreadExecutor 创建一个单线程的线程池. 串行执行所有任务. 这个唯一的线程因为异常结束线程池会生成一个新线程来替代
1. newFixedThreadPool 创建固定大小的线程池. 每提交一个任务就创建一个线程, 直到达到最大, 一旦达到就会保持不变, 如果某个线程因为异常结束线程池将会补充一个新线程
1. newCachedThreadPool 创建一个可缓存的线程池. 线程池大小超出任务数就会回收部分空闲(60 秒不执行任务)线程. 任务数增加时线程池会智能添加线程来处理任务, 线程池大小无限制
1. newScheduledThreadPool 创建一个大小无限的线程池. 支持定时及周期性执行任务的需求
1. newSingleThreadScheduleExecutor 创建一个单线程的线程池, 支持定时及周期性执行任务的需求


整体的交互如下
+ 调用 execute 添加任务时, 线程池将如下操作
  1. 如果正在运行的线程数量小于 corePoolSize, 则马上创建线程运行此任务 而不进行排队
  1. 如果大于或等于 corePoolSize 则将任务放入队列 而不添加新线程
  1. 如果无法将请求加入队列(队列满了)
    + 如果正在运行的线程数量小于 maximumPoolSize 则创建线程运行
    + 如果大于或等于 maximumPoolSize 则执行拒绝策略
+ 当线程执行完之后会从队列中取下一任务来执行
+ 当有线程空闲了 keepAliveTime 且运行的线程数大于 corePoolSize 则停掉此线程, 最终会收缩到 corePoolSize 的大小说明


队列的排队有三种通用策略
1. 直接提交. 此种策略的默认选项是 SynchronousQueue, 它将任务直接提交给线程而不保持它们. 
   如果不存在可用于立即运行任务的线程, 则试图把任务加入队列将失败, 因此会构造一个新的线程.
   此策略可以避免在处理可能具有内部依赖性的请求集时出现锁.
   直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务.
   当命令以超过队列所能处理的平均数连续到达时, 此策略允许无界线程具有增长的可能性.
1. 无界队列(例如不具有预定义容量的 LinkedBlockingQueue)将导致队列永远可以加入(除非到达 int.max)
   因此设置的有限 maximumPoolSize 的值也就无效了,
   当每个任务完全独立于其他任务时(即任务执行互不影响), 适合于使用无界队列.
   例如在 Web 页服务器中. 这种排队可用于处理瞬态突发请求
1. 有界队列. 当使用有限的 maximumPoolSizes 时, 有界队列(如 ArrayBlockingQueue)有助于防止资源耗尽,
   但是可能较难调整和控制. 队列大小和最大池大小需要相互折衷: 
   使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销,
   但是可能导致人工降低吞吐量. 如果任务频繁阻塞(例如, 如果它们是 I/O 边界), 则系统可能为超过您许可的更多线程安排时间.
   使用小型队列通常要求较大的池大小, CPU 使用率较高, 但是可能遇到不可接受的调度开销, 这样也会降低吞吐量.

+ 直接提交, 也就是像 SynchronousQueue 这种
#+BEGIN_SRC java
new ThreadPoolExecutor(1, 2,
        30, TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>(),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy()
);
#+END_SRC
假定每个任务都永远不会执行完, 第一个任务将会正常执行,
第二个任务将试图放入队列, SynchronousQueue 尽管其是无界的但是也无法加入, 此时还未超出 maximumPoolSize 所以会建一个线程来运行,
此时再来第三个任务, 将会执行拒绝策略.

在使用 SynchronousQueue 时通常要求 maximumPoolSize 是无界的, 这样可以避免上面的问题. 关于 SychronousQueue 见下面的代码
#+BEGIN_SRC java
SynchronousQueue<String> queue = new SynchronousQueue<>();
for (int i = 0; i < 5; i++) {
    new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date()) + " 线程名: " +
                        Thread.currentThread().getName() + ", 从队列中取出值 " + queue.poll(5, TimeUnit.SECONDS));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }).start();
}
for (int i = 0; i < 6; i++) {
    new Thread(new Runnable() {
        @Override
        public void run() {
            String random = String.valueOf(new Random().nextInt(1000));
            try {
                if (queue.offer(random, 6, TimeUnit.SECONDS)) {
                    System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date()) + " 线程名: " +
                            Thread.currentThread().getName() + ", 在队列中放入值 " + random);
                } else {
                    System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date()) + " 线程名: " +
                            Thread.currentThread().getName() + ", 在队列中放入值 " + random + " 失败");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }).start();
}
#+END_SRC

+ 使用无界队列策略, 也就是像默认构造的 LinkedBlockingQueue 这种
使用此种队列策略时, 当运行线程数达到 corePoolSize 后, 将会放入队列, 因为队列是无界的, 所以总是可以加入.
这样一来, 将永远不会触发产生新的线程, 所以在这种情况下, maximumPoolSize 的设置是无意义的.
这种方式通常来说是比较常见的, 如果添加任务的速度远远超过任务的处理时间, 而且还不断增加, 很容易消耗资源

+ 有界队列, 比如使用固定大小的 LinkedBlockingQueue 或 ArrayBlockingQueue 这种
#+BEGIN_SRC java
new ThreadPoolExecutor(1, 2,
        30, TimeUnit.SECONDS,
        new LinkedBlockingQueue<Runnable>(5), //new ArrayBlockingQueue<Runnable>(5)
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy()
);
#+END_SRC
#+BEGIN_EXAMPLE
这是最为复杂的使用, 所以 Executors 中也没有相关的静态方法, 跟上面的相比, 最大的特点是可以防止资源被耗尽.

假设 corePoolSize 是 2, maximumPoolSize 是 6, 队列大小是 4, 当加入 15 个线程时, 执行顺序类似于这样:
执行 1、2 线程, 线程 3 ~ 6 放入队列, 7 ~ 10 会被马上执行(因为队列满了), 假定此时每个线程都还没有执行完.
此时 core 达到了, max 也到达了, 队列也满了而后 11 ~ 15 将会执行拒绝策略.

最终会执行的线程是: 1、2、7、8、9、10、3、4、5、6
#+END_EXAMPLE

总的来说, 使用 ThreadPoolExecutor 还是很需要技巧的
+ 无界 queue 可能会耗尽系统资源
+ 有界 queue 可能不能很好的满足性能, 需要调节线程数和 queue 的大小
