java 有三大知名的 jvm gc 机制:
1. SUN 的 HotSpot
2. BEA 的 JRockit
3. IBM 的 J9

自从 Oracle 把 BEA 和 sun 收了之后后, JRockit 会被融入到 HotSpot 中来, 而 J9 又因为版权只能在 IBM 授权的机器上用, 所以后面的主流还会一直是 HotSpot.

要说 jvm 就必须先讲 jmm, 其实主要就堆和栈, 本来还有寄存器区, 本地方法区(jni 调用), 这俩区域不受程序管控, 也不多说, 重点说堆栈.

堆是公共区域, 栈是线程私有区域. 比如一个方法里面的临时变量 String a = "123"; a 这个引用(也就是 等号 左边的值)就是放在栈里面的, 当方法所在的线程执行完就会被抹掉. 这一块不够用的情况并不多见, 当方法递归(方法调用的行为也是在栈里面)的层次太多会抛出

最复杂的就是堆, 它里面的结构从 dump log 里面可以有一个大致印象

#+BEGIN_EXAMPLE
Heap
  PSYoungGen
    eden space
    from space
    to   space
  ParOldGen
    Object space
  Metaspace
    Class  space
#+END_EXAMPLE

1.8 之前 metaspace 又叫 永久代(Permanent Generation, JRockit 和 J9 里面管这块叫方法区 Method Area). 主要存的是 java 的第一公民「类」相关的信息, 很长一段时间这块区域都是不会 gc 的, 现在类的动态加载越来越多, 1.8 的 gc 已经开始对这一块伸出了触手(1.7 有没有开始还不确定).

只针对 young 的叫 minor gc, 针对 old 的叫 major gc, 因为 major 的时候一定会先来一次 minor, 所以又叫 full gc, 这样分块 gc 的概念又叫分代回收.

绝大多数时候, System.gc() 都会触发 gc 开始干活, 除非启动 java 命令的时候加一个抑制的命令, 一块空间经过了多次 minor 还活着就转到 major 的数值的阀值默认是 15, 也可以在启动 java 的时候加一个命令改, 基本每个这种(堆初始化及最大值啊, 新生代大小啊, 永久代初始及最大值啊)都可以通过加参数来处理

判断一块空间是不是 gc 目前还只有两种方法, 一个是可达性分析, 一个是计数器.

可达性分析的重点就是一课树, 树以外的就是垃圾, 树根(gc root)主要有下面四种(引自 深入理解 jvm : 高级特性与最佳实践):
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象;
2. 方法区中类静态属性引用的对象;
3. 方法区中常量引用的对象;
4. 本地方法栈中 JNI(即一般说的 Native 方法)引用的对象;

计数器的重点就是在多线程的时候做 +-1 的时候会提升复杂度, 而且如果某个地方忘记操作就悲剧了.

基于确定是不是垃圾的这两种方法(可达性分析和计数器), 一共衍生出三种垃圾回收算法.

1. 标记-清除. 就是两次循环, 第一次循环那颗树, 给每个对象一个 flag, 第二次循环整片空间, 没打标的回收, 这种会出现碎片, 所以在这个基础上变种出 标记-压缩, 它会在回收之后把非垃圾的尽量压缩到一起.
2. 复制-收集. 这是一种很大胆的算法, 就是把整颗树复制到一个新地方, 再把原来那份的空间整个回收
3. 引用计数器. 容易有循环依赖, 这个没什么好多说的.

其他的算法基本都是这三个的变种, 或者杂交一下, 或者来一点小改动. 基本都离不开这三种.

是不是垃圾和上面的三种算法, 都是那一时期发现的, 直到现在都还没有人发现一个新的方法. 如果有, 发个 pager, 没准能得图灵奖.

jvm 里面, 新生代的算法是基于 复制-收集 来实现, 从 from to 这两区域的名称基本就能感觉得出来. 老年代是基于 标记-压缩 来实现.

然后就是几种回收策略.
1. serial gc, 这是最早的, 单线程, 而且会 stw(stop the world), 可以用启动命令来指定, 下面一样
2. parallel gc. 1.8 默认的, 跟上面不同的是多线程, 也会 stw
3. cms. 比上面的会了一些细节, 可以只 stop 部分线程, 可以跟上面的默认同时存在
4. g1, 1.7 才出现的, 说是用来取代 cms, 分代, 整理, 可预见性. 说是不用 stw, 应该也是在细节上做了一些更好的优化

