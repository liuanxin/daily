要说 jvm 就必须先讲 jmm, 其实主要就堆和栈, 本来还有寄存器区, 本地方法区(jni 调用), 这俩区域跟他们的名字一样, 也不受程序管控, 也不多说, 重点说堆栈.

堆是公共区域, 栈是线程私有区域. 比如一个方法里面的临时变量 String a = "123"; a 这个引用(也就是 等号 左边的值)就是放在栈里面的, 当方法所在的线程执行完就会被抹掉. 这一块不够用的情况并不多见, 当方法递归(也是在栈里面)的层次太多会抛出

最复杂的就是堆, 它里面的结构从 dump log 里面可以有一个大致印象

#+BEGIN_EXAMPLE
Heap
  PSYoungGen
    eden space
    from space
    to   space
  ParOldGen
    Object space
  Metaspace
    Class  space
#+END_EXAMPLE

1.8 之前 metaspace 是 方法区. 主要存的是 java 的第一公民类相关的信息, 1.8 之前这一块是不会 gc 的, 现在动态加载越来越多, gc 也开始对这一块伸出了触手.

只针对 young 的叫 minor gc, 针对 old 的叫 major gc, 因为 major 的时候一定会先来一次 minor, 所以又叫 full gc, 这样分块 gc 的概念又叫分代回收.

绝大多数时候, System.gc() 都会触发 gc 开始干活, 除非启动 java 命令的时候加一个抑制的命令, 一块空间经过了多次 minor 还活着就转到 major 的数值的阀值默认是 15 还是多少具体得去查一下, 也可以在启动 java 的时候加一个命令, 基本每个这种(堆初始化及最大值啊, 新生代大小啊, 永久代初始及最大值啊)都可以通过加参数来处理

判断一块空间是不是 gc 目前还只有两种方法, 一个是可达性分析, 一个是计数器.

可达性分析的重点就是一课树, 树以外的就是垃圾, 怎么保证一个对象是树根(root)这我不清楚, 应该是达到一些指定的条件就可以做为根吧.

计数器就没啥好多说的, 他的重点就是在多线程的时候做 +-1 的时候会提升复杂度, 而且如果某个地方忘记操作就悲剧了.

基于确定是不是垃圾的这两种方法(可达性分析和计数器), 一共衍生出三种垃圾回收算法.

1. 标记-清除. 就是两次循环, 第一次循环那颗树, 给每个对象一个 flag, 第二次循环整片空间, 没打标的回收, 想都想得到这样容易出现碎片, 空间利用并不好, 所以在这个基本上变种出一种 标记-压缩, 跟这个没有多大区别, 只是在回收之后把非垃圾的挪到一起.
2. 复制-收集. 这是一种很大胆的算法, 就是把整颗树复制到一个新地方, 再把原来那份的空间整个回收
3. 引用计数器. 容易有循环依赖, 这种不多说了

其他的算法基本都是这三种的变种, 或者杂交一下, 或者来一点小改动. 基本都离不开这三种

确定是不是垃圾和三种算法, 都是 60 年代发现的, 直到现在都还没有人发现一个新的方法. 如果有, 发个 pager, 没准能得图灵奖.

jvm 里面, 新生代的算法通过是基于 复制-收集, from to 这两区域基本就能感觉得出来.

然后就是几种回收策略.
1. serial gc, 这是最早的, 单线程, 而且会 stw(stop the world), 可以用启动命令来指定, 下面一样
2. parallel gc. 1.8 默认的, 跟上面不同的是多线程, 也会 stw
3. cms. 比上面的会了一些细节, 可以只 stop 部分线程, 可以跟上面的默认同时存在
4. g1, 1.7 才出现的, 说是用来取代 cms, 分代, 整理, 可预见性. 说是不用 stw, 应该也是在细节上做了一些更好的优化

g1 据说是当堆大小在超大时才会有明显的效果(比如 1T 的内存). 基本来说, 现在使用 默认 + cms 是够用了的
