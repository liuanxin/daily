
Java 的 [[http://java-latte.blogspot.com/2014/04/Semaphore-CountDownLatch-CyclicBarrier-Phaser-Exchanger-in-Java.html][并发包]] 共有下面这 5 种线程操作. 当然, 都是基于 cas 指令来完成的.
+ 信号量(Semaphore) ==> 控制某一时刻只允许指定数据的线程执行
+ 计数器(CountDownLatch) ==> 运行完指定数量的线程后, 运行某个单线程(也可以在主线程中处理)
+ 栅栏(CyclicBarrier) ==> 所有的线程都准备好了, 才能再各自继续往下执行
+ 数据交换(Exchanger) ==> 两个线程在运行时, 相互之间交换数据
+ Phaser(找不到好的中文名称来描述) ==> 有 计数器(CountDownLatch) 和 栅栏(CyclicBarrier) 的功能. 从 1.7 开始才有

** 信号量(Semaphore)

同一时间只允许指定数量的线程执行.
#+BEGIN_SRC java
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/** 信号量 */
public class SemaphoreTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Semaphore semaphore = new Semaphore(3);

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 10; i++) {
            executor.submit(new Worker());              // pool
            //new Thread(new Worker()).start();
        }
        executor.awaitTermination(3, TimeUnit.SECONDS); // pool
        System.exit(0);                                 // pool
    }

    static class Worker implements Runnable {
        @Override
        public void run() {
            System.out.println("线程 " + Thread.currentThread().getName() + " 开始");

            // 向信号量申请许可. 如果信号量中的许可用完了, 当前线程需要等待
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 向信号量申请许可成功

            // 业务处理开始
            System.out.println("线程 " + Thread.currentThread().getName() + " 获得了许可, 开始执行");
            try {
                Thread.sleep(20 * (new Random().nextInt(4)));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程 " + Thread.currentThread().getName() + " 执行完毕, 开始释放许可");
            // 业务处理结束, 准备释放许可

            // 让信号量释放当前线程的许可
            semaphore.release();
            System.out.println("线程 " + Thread.currentThread().getName() + " 许可释放完成");
        }
    }
}
#+END_SRC

运行结果大致如下:
#+BEGIN_SRC text
线程 pool-1-thread-1 开始
线程 pool-1-thread-1 获得了许可, 开始执行
线程 pool-1-thread-3 开始
线程 pool-1-thread-3 获得了许可, 开始执行
线程 pool-1-thread-4 开始
线程 pool-1-thread-4 获得了许可, 开始执行
线程 pool-1-thread-5 开始
线程 pool-1-thread-2 开始
线程 pool-1-thread-1 执行完毕, 开始释放许可
线程 pool-1-thread-1 许可释放完成
线程 pool-1-thread-5 获得了许可, 开始执行
线程 pool-1-thread-3 执行完毕, 开始释放许可
线程 pool-1-thread-3 许可释放完成
线程 pool-1-thread-2 获得了许可, 开始执行
线程 pool-1-thread-4 执行完毕, 开始释放许可
线程 pool-1-thread-4 许可释放完成
线程 pool-1-thread-5 执行完毕, 开始释放许可
线程 pool-1-thread-5 许可释放完成
线程 pool-1-thread-2 执行完毕, 开始释放许可
线程 pool-1-thread-2 许可释放完成
#+END_SRC


** 计数器(CountDownLatch)

当运行完指定数量的线程后, 运行某个单线程(也可以在主线程中处理)
#+BEGIN_SRC java
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/** 计数器 */
public class CountDownLatchTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static CountDownLatch latch = new CountDownLatch(3);

    public static void main(String[] args) throws Exception {
        executor.submit(new Waiter(latch));
        for (int i = 0; i < 3; i++) {
            executor.submit(new Decrement(latch));       // pool
        }
        executor.awaitTermination(3, TimeUnit.SECONDS);  // pool
        System.exit(0);                                  // pool


//        for (int i = 0; i < 3; i++) {
//            new Thread(new Decrement(latch)).start();
//        }
//
//        try {
//            latch.await();
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        System.out.println("计数器已经达到指定数量, 当前线程 " + Thread.currentThread().getName() + " 可以运行");
    }

    static class Waiter implements Runnable {
        CountDownLatch latch;
        Waiter(CountDownLatch latch) {
            this.latch = latch;
        }

        public void run() {
            System.out.println("非计数器线程 " + Thread.currentThread().getName() + " 开始");

            // 等待计数器为 0, 当还未减到 0 时, 当前线程将会等待
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("计数器已经达到指定数量, 当前非计数器线程 " + Thread.currentThread().getName() + " 可以运行了");

            // 业务处理开始.
        }
    }
    static class Decrement implements Runnable {
        CountDownLatch latch;
        Decrement(CountDownLatch latch) {
            this.latch = latch;
        }

        public void run() {
            System.out.println("计数器线程 " + Thread.currentThread().getName() + " 开始");

            // 线程开始执行
            try {
                Thread.sleep(20 * (new Random().nextInt(4)));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("计数器线程 " + Thread.currentThread().getName() + " 执行完毕");

            // 计数器递减
            latch.countDown();
        }
    }
}
#+END_SRC

运行结果大致如下:
#+BEGIN_SRC text
非计数器线程 pool-1-thread-1 开始
计数器线程 pool-1-thread-2 开始
计数器线程 pool-1-thread-2 执行完毕
计数器线程 pool-1-thread-2 开始
计数器线程 pool-1-thread-3 开始
计数器线程 pool-1-thread-2 执行完毕
计数器线程 pool-1-thread-3 执行完毕
计数器已经达到指定数量, 当前非计数器线程 pool-1-thread-1 可以运行了
#+END_SRC


** 栅栏(CyclicBarrier)

所有的线程都准备好了, 才能再各自继续往下执行
#+BEGIN_SRC java
import java.util.Random;
import java.util.concurrent.*;

/** 栅栏 */
public class CyclicBarrierTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static CyclicBarrier barrier = new CyclicBarrier(3);

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 10; i++) {
            // new Thread(new Worker(barrier)).start();
            executor.submit(new Worker(barrier));        // pool
        }
        executor.awaitTermination(3, TimeUnit.SECONDS);  // pool
        System.exit(0);                                  // pool
    }

    static class Worker implements Runnable {
        private CyclicBarrier barrier;
        Worker(CyclicBarrier barrier) {
            this.barrier = barrier;
        }
        @Override
        public void run() {
            System.out.println("线程 " + Thread.currentThread().getName() + " 开始");

            // 做基本的准备工作. 如 3 个人开始跑步前的准备
            try {
                Thread.sleep(20 * (new Random().nextInt(4)));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程 " + Thread.currentThread().getName() + " 准备好了");
            // 做基本的准备工作完成

            // 把当前线程放到指定数量的跑道前. 等待所有人全部准备好, 如果数量还没有达到, 当前线程就要一直等待, 不会再往下执行
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
            // 如果指定数量的线程都执行到了这里, 这一组线程就都可以往下执行了

            // 业务处理开始. 如 3 个人开始同时起跑
            System.out.println("线程 " + Thread.currentThread().getName() + " 出发");
            // ...
        }
    }
}
#+END_SRC

测试结果大致如下
#+BEGIN_SRC text
线程 pool-1-thread-1 开始
线程 pool-1-thread-2 开始
线程 pool-1-thread-3 开始
线程 pool-1-thread-4 开始
线程 pool-1-thread-6 开始
线程 pool-1-thread-5 开始
线程 pool-1-thread-7 开始
线程 pool-1-thread-9 开始
线程 pool-1-thread-10 开始
线程 pool-1-thread-10 准备好了
线程 pool-1-thread-8 开始
线程 pool-1-thread-2 准备好了
线程 pool-1-thread-1 准备好了
线程 pool-1-thread-1 出发
线程 pool-1-thread-10 出发
线程 pool-1-thread-2 出发
线程 pool-1-thread-9 准备好了
线程 pool-1-thread-8 准备好了
线程 pool-1-thread-3 准备好了
线程 pool-1-thread-4 准备好了
线程 pool-1-thread-9 出发
线程 pool-1-thread-3 出发
线程 pool-1-thread-8 出发
线程 pool-1-thread-6 准备好了
线程 pool-1-thread-5 准备好了
线程 pool-1-thread-7 准备好了
线程 pool-1-thread-5 出发
线程 pool-1-thread-4 出发
线程 pool-1-thread-6 出发
#+END_SRC


** 数据交换(Exchanger)

两个线程在运行时, 相互之间交换数据
#+BEGIN_SRC java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/** 数据交换 */
public class ExchangerTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Exchanger<List<Integer>> exchanger = new Exchanger<>();

    public static void main(String[] args) throws Exception {
        // new Thread(new Worker(exchanger)).start();
        // new Thread(new Worker(exchanger)).start();

        executor.submit(new Worker(exchanger));          // pool
        executor.submit(new Worker(exchanger));          // pool

        executor.awaitTermination(1, TimeUnit.SECONDS);  // pool
        System.exit(0);                                  // pool
    }

    static final Random RANDOM = new Random();
    static class Worker implements Runnable {
        Exchanger<List<Integer>> exchanger;
        List<Integer> info;
        Worker(Exchanger<List<Integer>> exchanger) {
            this.exchanger = exchanger;

            info = new ArrayList<>(Arrays.asList(RANDOM.nextInt(10), RANDOM.nextInt(100), RANDOM.nextInt(1000)));
        }

        public void run() {
            System.out.println("线程 " + Thread.currentThread().getName() + " 开始");
            try {
                // 开始交换数据
                List<Integer> exchangeInfo = exchanger.exchange(info);

                System.out.println("当前线程 " + Thread.currentThread().getName() + " 持有的数据是: " + info
                        + ", 交换过来的数据是 " + exchangeInfo);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
#+END_SRC

运行结果大致如下
#+BEGIN_SRC text
线程 pool-1-thread-1 开始
线程 pool-1-thread-2 开始
当前线程 pool-1-thread-1 持有的数据是: [0, 26, 181], 交换过来的数据是 [9, 25, 876]
当前线程 pool-1-thread-2 持有的数据是: [9, 25, 876], 交换过来的数据是 [0, 26, 181]
#+END_SRC


** Phaser(找不到好的中文名称来描述)

它拥有 计数器(CountDownLatch) 和 栅栏(CyclicBarrier) 的功能, 还提供了更丰富的操作. 从 1.7 开始才有

*** 替代 计数器(CountDownLatch)
#+BEGIN_SRC java
import java.util.Random;
import java.util.concurrent.*;

/** 1.7 之后新增加的功能, 可替代 栅栏 和 计数器外. 当前示例可以替换 CountDownLatch */
public class PhaserReplaceCountDownLatchTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Phaser phaser = new Phaser(3);

    public static void main(String[] args) throws Exception {
        executor.submit(new Waiter(phaser));
        for (int i = 0; i < 3; i++) {
            executor.submit(new Decrement(phaser));      // pool
        }
        executor.awaitTermination(3, TimeUnit.SECONDS);  // pool
        System.exit(0);                                  // pool


//        for (int i = 0; i < 3; i++) {
//            new Thread(new Decrement(phaser)).start();
//        }
//        phaser.awaitAdvance(phaser.getPhase());
//        System.out.println("计数器已经达到指定数量, 当前线程 " + Thread.currentThread().getName() + " 可以运行");
    }

    static class Waiter implements Runnable {
        Phaser phaser;
        Waiter(Phaser phaser) {
            this.phaser = phaser;
        }

        public void run() {
            System.out.println("非计数器线程 " + Thread.currentThread().getName() + " 开始");

            // 等待计数器为 0, 当还未减到 0 时, 当前线程将会等待
            phaser.awaitAdvance(phaser.getPhase());

            System.out.println("计数器已经达到指定数量, 当前非计数器线程 " + Thread.currentThread().getName() + " 可以运行了");

            // 业务处理开始.
        }
    }
    static class Decrement implements Runnable {
        Phaser phaser;
        Decrement(Phaser phaser) {
            this.phaser = phaser;
        }

        public void run() {
            System.out.println("计数器线程 " + Thread.currentThread().getName() + " 开始");

            // 线程开始执行
            try {
                Thread.sleep(20 * (new Random().nextInt(4)));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("计数器线程 " + Thread.currentThread().getName() + " 执行完毕");

            // 计数器递减
            phaser.arrive();
        }
    }
}
#+END_SRC

运行结果大致如下
#+BEGIN_SRC text
非计数器线程 pool-1-thread-1 开始
计数器线程 pool-1-thread-2 开始
计数器线程 pool-1-thread-3 开始
计数器线程 pool-1-thread-4 开始
计数器线程 pool-1-thread-4 执行完毕
计数器线程 pool-1-thread-2 执行完毕
计数器线程 pool-1-thread-3 执行完毕
计数器已经达到指定数量, 当前非计数器线程 pool-1-thread-1 可以运行了
#+END_SRC


*** 替代栅栏(CyclicBarrier)
#+BEGIN_SRC java
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/** 1.7 之后新增加的功能, 可替代 栅栏 和 计数器外. 当前示例可以替换 CyclicBarrier */
public class PhaserReplaceCyclicBarrierTest {

    private static ExecutorService executor = Executors.newCachedThreadPool();
    private static Phaser phaser = new Phaser(3);

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 3; i++) {
            // new Thread(new Worker(phaser)).start();
            executor.submit(new Worker(phaser));         // pool
        }
        executor.awaitTermination(3, TimeUnit.SECONDS);  // pool
        System.exit(0);                                  // pool
    }

    static class Worker implements Runnable {
        private Phaser phaser;
        Worker(Phaser phaser) {
            this.phaser = phaser;
            //phaser.register();
        }
        @Override
        public void run() {
            System.out.println("线程 " + Thread.currentThread().getName() + " 开始");

            // 做基本的准备工作
            try {
                Thread.sleep(20 * (new Random().nextInt(4)));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程 " + Thread.currentThread().getName() + " 准备好了");

            // 把当前线程放到指定数量的跑道前. 等待所有人全部准备好
            phaser.arriveAndAwaitAdvance();

            // 如果指定数量的线程都执行到了这里, 这一组线程就都可以往下执行了

            // 业务处理开始. 如 3 个人开始同时起跑
            System.out.println("线程 " + Thread.currentThread().getName() + " 出发");
            // ...
        }
    }
}
#+END_SRC

运行结果大致如下
#+BEGIN_SRC text
线程 pool-1-thread-1 开始
线程 pool-1-thread-2 开始
线程 pool-1-thread-3 开始
线程 pool-1-thread-1 准备好了
线程 pool-1-thread-2 准备好了
线程 pool-1-thread-3 准备好了
线程 pool-1-thread-3 出发
线程 pool-1-thread-1 出发
线程 pool-1-thread-2 出发
#+END_SRC
