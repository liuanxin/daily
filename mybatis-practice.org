
*** 通过 Example 简化查询

如果我们想要生成如下的 sql 语句:
#+BEGIN_SRC sql
select xxx from `t_user` where user_name = 'sz' and level > 1 and verify in (1, 2, 3)
#+END_SRC
这样构建  example 来达到上面的效果
#+BEGIN_SRC java
UserExample userExample = new UserExample();
userExample.or().andUserNameEqualTo(phone).andLevelGreaterThan(1).andVerifyIn(Arrays.asList(1, 2, 3));
userMapper.selectByExample(userExample);
#+END_SRC

同样的 where 条件也可以用在 update 和 delete 上
#+BEGIN_SRC java
UserExample userExample = new UserExample();
userExample.or().andUserNameNameEqualTo(phone).andLevelGreaterThan(1).andVerifyIn(Arrays.asList(1, 2, 3));
userMapper.updateByExampleSelective(new User().setPassword("abc"), userExample);
#+END_SRC
上面将会生成如下的 sql 语句
#+BEGIN_SRC sql
update `t_user` set password='abc' where user_name = 'sz' and level > 1 and verify in (1, 2, 3)
#+END_SRC

如果要生成 or 语句, 可以像这样
#+BEGIN_SRC java
UserExample userExample = new UserExample();
userExample.or().andUserNameEqualTo("xxx").andCreateTimeLessThan(new Date());
userExample.or().andEmailEqualTo("xxx").andCertIsNotNull();
userExample.or().andPhoneEqualTo("xxx").andVerifyIn(Arrays.asList(1, 2, 3));
userMapper.selectByExample(userExample);
#+END_SRC
生成的 sql 如下
#+BEGIN_SRC sql
select xx from `t_user` where (name = 'xx' and create_time &lt; now) 
    or (email = 'xxx' and `cert` is not null) 
    or (phone = 'xxx' and verify in (1, 2, 3))
#+END_SRC

如果要生成条件复杂的 or 语句(比如在一个 and 条件里面有好几个 or), exmple 将会无法实现, 此时就需要手写 sql 了

-----
*** 何时需要手工写自己的 _customer mapper 文件
当有一些不得不联表的 sql 语句, 或者基于 example 很难生成的 or 查询, 此时放在 custom.xml 中, 确保自动生成和手写的 sql 分开管理.

PS: 尽量不要使用 join 来联表, 尽量由应用程序来组装数据并每次向数据库发起单一且易维护的 sql 语句. 阿里在 17 年初出的开发手册中也明确说明: 超级三个表禁止 join, 是有其原因的

-----
*** 如何把枚举类映射成数据库字段
比如下面的 性别
#+BEGIN_SRC java
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

/** 用户性别 */
public enum Gender {

    Nil(0, "未知"), Male(1, "男"), Female(2, "女");

    private int code;
    private String value;
    private Gender(int code, String value) {
        this.code = code;
        this.value = value;
    }

    /** 显示用 */
    public String getValue() {
        return value;
    }
    /** 存进数据库的实际用 */
    @JsonValue
    public int getCode() {
        return code;
    }

    /** 序列化转换时调用 */
    @JsonCreator
    public static Gender deserializer(Object obj) {
        if (obj != null) {
            String source = obj.toString().trim();
            if (!"".equals(source)) {
                for (Gender enumInfo : values()) {
                    if (source.equalsIgnoreCase(enumInfo.name())
                            || source.equalsIgnoreCase(String.valueOf(enumInfo.getCode()))
                            || source.equalsIgnoreCase(String.valueOf(enumInfo.getValue()))) {
                        return enumInfo;
                    }
                }
            }
        }
        return null;
    }
}
#+END_SRC
其中 code 和 value 都要有, 一个用来存入数据库, 一个用来显示, 两个 jackson 的注解已经说明了序列化和反序列化的规则, 此时, 还需要让 mybatis 也知道, 我在每个模块的 test 中放了 GenerateEnumHandle 这个测试类, 运行后会在当前模块的 handler 包中生成对应的枚举处理类, 就像下面这样
#+BEGIN_SRC java
import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * 当前 handle 是自动生成的
 *
 * @see org.apache.ibatis.type.TypeHandlerRegistry
 * @see org.apache.ibatis.type.EnumTypeHandler
 * @see org.apache.ibatis.type.EnumOrdinalTypeHandler
 */
public class GenderHandler extends BaseTypeHandler {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Gender parameter,
                                    JdbcType jdbcType) throws SQLException {
        ps.setInt(i, parameter.getCode());
    }

    @Override
    public Gender getNullableResult(ResultSet rs, String columnName) throws SQLException {
        return U.toEnum(Gender.class, rs.getObject(columnName));
    }

    @Override
    public Gender getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        return U.toEnum(Gender.class, rs.getObject(columnIndex));
    }

    @Override
    public Gender getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        return U.toEnum(Gender.class, cs.getObject(columnIndex));
    }
}
#+END_SRC
将这个类装载到 mybatis 的上下文中去, 这样在整个项目过程中, 任意地方都可以直接使用枚举而不需要基于数值转来转去

-----

*** 如何开启 MyBatis 端的 redis 缓存
在相应的模块中添加如下的配置
#+BEGIN_SRC xml
<properties>
    <mybatis-redis-cache.version>1.2.2</mybatis-redis-cache.version>
</properties>

<dependency>
    <groupId>com.github.liuanxin</groupId>
    <artifactId>mybatis-redis-cache</artifactId>
    <version>${mybatis-redis-cache.version}</version>
    <scope>provided</scope>
</dependency>
#+END_SRC

放一个类进 spring 的上下文
#+BEGIN_SRC java
@Configuration
public class MybatisCacheConfig {
    @Bean
    public RedisContextUtils redisContext() {
        return new RedisContextUtils();
    }
}
#+END_SRC

而后在对应的 mapper.xml 中添加下面的代码, 则此 xml 中所有的 sql 都会走 redis 缓存
#+BEGIN_SRC xml
<cache type="com.github.liuanxin.caches.MybatisRedisCache" />
#+END_SRC

#+BEGIN_EXAMPLE
type : 基础缓存类型, 默认是 PerpetualCache(就是一个 HashMap)
flushInterval : 缓存刷新间隔. 单位: 毫秒. 默认情况是不设置, 也就是没有刷新间隔, 缓存仅仅调用语句时刷新
size : 缓存条数, 默认是 1024
readOnly : 是否只读, 默认是 false
blocking : 操作时是否阻塞, 默认是 false
eviction : 排除算法缓存类型. 默认是 LRU, 还有 FIFO
    LRU   Least Recently Used 最近最少使用的: 移除最长时间不被使用的对象
    FIFO  First In First Out 先进先出: 按对象进入缓存的顺序来移除它们
    SOFT  软引用: 移除基于垃圾回收器状态和软引用规则的对象
    WEAK  弱引用: 更积极地移除基于垃圾收集器状态和弱引用规则的对象
#+END_EXAMPLE

-----

*** 一些提升开发效率的插件

lombok plugin: 在类上标注解来自动给实体生成 set get 及构造方法
free mybatis plugin: 直接在 mapper 类及 xml 中快速定位, 也可以在 xml 中手写 sql 时有更多提示
